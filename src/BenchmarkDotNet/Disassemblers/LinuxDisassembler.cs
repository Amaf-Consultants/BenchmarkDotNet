using System.IO;
using System.Xml.Serialization;
using BenchmarkDotNet.Disassembler;
using JetBrains.Annotations;

namespace BenchmarkDotNet.Diagnosers 
{
    internal class LinuxDisassembler
    {
        private readonly bool printAsm, printSource, printPrologAndEpilog;
        private readonly int recursiveDepth;

        [PublicAPI]
        public LinuxDisassembler(DisassemblyDiagnoserConfig config)
        {
            printAsm = config.PrintAsm;
            printSource = config.PrintSource;
            printPrologAndEpilog = config.PrintPrologAndEpilog;
            recursiveDepth = config.RecursiveDepth;
        }

        [PublicAPI]
        public DisassemblyResult Disassemble(DiagnoserActionParameters parameters)
        {
            var settings = BuildDisassemblerSettings(parameters);

            var disassembledMethods = Program.Disassemble(settings);

            return Map(disassembledMethods);
        }

        private Settings BuildDisassemblerSettings(DiagnoserActionParameters parameters)
        {
            return new Settings(
                processId: parameters.Process.Id,
                typeName: $"BenchmarkDotNet.Autogenerated.Runnable_{parameters.BenchmarkId.Value}",
                methodName: DisassemblerConstants.DisassemblerEntryMethodName,
                printAsm: printAsm,
                printSource: printSource,
                printPrologAndEpilog: printPrologAndEpilog,
                recursiveDepth: recursiveDepth,
                resultsPath: default
            );
        }

        // the contracts have 1:1 mapping and serializing and deserializing them is the simplest way to map them
        private static DisassemblyResult Map(Disassembler.DisassembledMethod[] disassembledMethods)
        {
            var result = new Disassembler.DisassemblyResult()
            {
                Methods = disassembledMethods
            };

            var fromSerializer = new XmlSerializer(typeof(Disassembler.DisassemblyResult));
            var toSerializer  = new XmlSerializer(typeof(Diagnosers.DisassemblyResult));
            
            using (var stream = new MemoryStream())
            {
                fromSerializer.Serialize(stream, result);

                stream.Position = 0;

                return (DisassemblyResult)toSerializer.Deserialize(stream);
            }
        }
    }
}